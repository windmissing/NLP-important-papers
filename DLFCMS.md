# 摘要

我们提出了一个基于高级参数的合成角色运动的框架，这样产生的运动尊重人体运动流形。

> **[warning]**
> 什么是高级参数？

这个框架在大型运动捕捉数据集上训练。学习到的运动流形由卷积自动编码器的隐藏单元表示。  

> **[success]** 运动数据集 ---(卷积AutoEncoder)---> 运动流形的表示  

它代表了稀疏分量中的运动数据，这些分量可以组合以产生广泛的复杂运动。  

> **[warning]** 什么是稀疏分量中的运动数据？  

为了从高级参数映射到运动流形，我们在经过训练的自动编码器之上堆叠了一个深度前馈神经网络。该网络经过训练，可根据参数生成逼真的运动序列，例如角色应遵循的地形曲线，或拳打脚踢的目标位置。  

> **[success]** 高级参数 ---(深度前馈网络)---> 运动序列  
**[warning]** 这两个网络是怎么结合到一起的？  

前馈控制网络和运动流形是独立训练的。这允许用户根据所需的接口在前馈网络之间轻松切换，而无需重新训练运动流形。  

> **[warning]** 为什么要切换前馈网络？  

一旦生成运动，就可以通过在运动流形空间中执行优化来对其进行编辑。  

> **[warning]** "在运动流形空间中执行优化"是什么意思？编辑的对象是什么？  

这允许施加运动学约束，或改变运动的风格，同时确保编辑的运动保持自然。因此，该系统可以生成平滑、高质量的运动序列，而无需对训练数据进行任何手动预处理。

> **[warning]**
> “施加运动学约束，改变运动的风格”是由什么网络实现？  
> “编辑的运动保持自然”是由什么网络实现？  
其它方法需要做怎样的预处理？  

---

**关键词**：深度学习，卷积神经网络，自编码器，人体运动，角色动画，流形学习   
**概念： •计算方法→运动捕捉**；

# 介绍

数据驱动的运动合成允许动画师根据高级参数生成令人信服的角色运动。 这种方法极大地帮助了动画制作，因为动画师只需要通过关键帧提供高级指令而不是低级细节。   

> **[warning]**  
关键帧是什么？与高级指令是怎么结合的？  
高级指令和高级参数是什么关系？  

计算机动画中已经提出了各种利用大型运动捕捉数据集和机器学习来参数化运动的技术。

---

目前可用的大多数数据驱动方法都需要大量的手动数据预处理，包括运动分割、对齐和标记。  
> **[warning]** 运动分割、对齐和标记分别具体要做什么？  

任何阶段的错误都很容易导致最终动画的失败。 因此，这种预处理通常是通过大量人工干预小心执行的，以确保输出运动看起来平滑自然。 这使得完全自动化变得困难，因此这些系统通常需要专门的技术开发人员来维护。

---

在本文中，我们提出了一种基于深度学习框架的动画合成和编辑模型，该模型可以使用大量人体运动数据自动学习非线性流形中运动数据的嵌入(embedding)，无需手动数据预处理或人为干涉。

> **[success] 运动数据的embedding是什么？**   
答：embedding应该是指用于表示运动数据的向量。这种向量不是人为定义的稀疏向量，可以是自动学到的人看不懂的向量。   

> **[warning]** 为什么这个过程以前需要手动预处理而现在不需要？  

我们在大型运动数据库上训练卷积自动编码器，以便它可以再现给出的运动数据并作为后续的输入，还可以通过插值合成新的运动。

> **[success] Embedding为什么能再现运动数据？为什么能合成新的运行数据？**  
答：用embedding代表运动数据。使用同样的embedding就能重现同样的运行数据。两个embedding通过运算可以得到新的embedding。合理的设计embedding之间的运算，就能通过两个运动数据合成新的运动数据。  

这种无监督的非线性流形学习过程不需要任何运动分割或对齐，这使得该过程比以前的方法容易得多。  

> **[warning]** 运动分割或对齐用在什么地方？为什么这个过程以前需要手动预处理而现在不需要？  

在这个自动编码器之上，我们堆叠了另一个前馈神经网络，它将高级参数映射到低级人体运动，由自动编码器的隐藏单元表示。

> **[success] 什么是高级参数？**  
答：角色应该遵循的某些地形上的曲线，或者用于拳击和踢腿的末端执行器的轨迹   
**什么是低级人体运动？**  
答：根据高级参数做出的运动的运动数据  
**高级和低级从哪里来？**  
答：高级是指更接近人类的理解。低级是指更接近计算机的数据。  
**为什么由隐藏单元表示，还不是输出层表示？**  
答：AutoEncoder是非监督学习，它的输出层的目标就是它自己的输入X。AutoEncoder对X的embedding保存在中间层的隐藏单元。  

有了这个，用户可以从直观的输入中轻松生成逼真的人体运动序列，例如角色应该遵循的某些地形上的曲线，或者用于拳击和踢腿的末端执行器的轨迹。由于前馈控制网络和运动流形是独立训练的，用户可以根据所需的接口轻松交换和重新训练前馈网络。我们的方法本质上也是并行的，这使得计算速度非常快，并且非常适合主流动画包。  

> **[warning]** 为什么能够并行？AutoEncoder没有训练好，FC怎么训练？  

---

我们还提出了在运动流形空间中编辑运动数据的技术。 卷积自编码器的隐藏单元以稀疏和连续的方式表示运动，因此调整该空间中的数据可以保持运动的自然性和平滑性，同时仍然允许再现身体的复杂运动。  

> **[warning]** 为什么embedding是稀疏的？  

这种编辑的一个示范示例是通过最小化合成运动的隐藏单元与参考运动的隐藏单元的 Gram 矩阵之间的差异，将一种运动的风格与另一种运动的时间相结合 [Gatys et al. 2015]。  

> **[success]** FNN负责运动的时间序列，AutoEncoder负责运动的风格。FC和AE分别训练，可以实现风格与时间的自由组合。  
指令 --- 运动数据序列 ---(AutoEncoder)---> Embedding序列 Target
指令 ---(FNN)--- Embedding序列 Predict  
通过最小化Embedding Target和Embedding Predict的Gram距离来训练FNN。 

---

总之，我们的贡献如下：

- 一个快速、并行的深度学习框架，用于从高级参数合成角色动画。
- 一种在运动流形上进行运动编辑的方法，用于满足用户约束和变换运动风格。

# 相关工作

我们首先回顾基于内核的运动合成方法，这些方法一直是通过混合运动捕捉数据来合成运动的主要技术。

> **[warning]** 运动捕捉数据是指什么？

我们接下来回顾交互式角色控制的方法，其中用户指令用于使用运动数据库合成新运动。 最后，我们回顾了深度学习中的方法以及它们如何应用于角色动画。

---

**基于内核的运动混合方法** 径向基函数 (RBF) 可有效混合同一类的多个运动。罗斯等人 [1998] 将同一类的动作称为“动词”，并根据角色需要移动或伸出的方向使用 RBF 对它们进行插值。罗斯等人 [2001] 通过将关节位置映射到角色的姿势，展示了 RBF 的反向运动学用法。

> **[warning]** 怎样使用RBF进行插值？反向运动学是什么？

为了使混合运动看起来合理，需要沿着时间线对运动进行分类和对齐。 Kovar 和 Gleicher [2004] 通过计算运动的相似性并使用动态时间扭曲对齐它们来自动化这个过程。然而，由于缺乏处理噪声和方差的机制，RBF 方法很容易过拟合数据。 Mukai 和 Kuriyama [2005] 通过使用高斯过程 (GP) 克服了这个问题，其中优化了元参数以使模型适合数据。

> **[warning]** 元参数是超参数的意思吗？用GP克服过拟合是指人为加噪？

格罗乔等人 [2004] 应用高斯过程潜在变量模型 (GPLVM) 将运动数据映射到低维空间，以便动画师可以直观地控制角色。

> **[warning]** 高斯过程潜在变量模型 (GPLVM)？

王等人 [2005] 将 GPLVM 应用于时间序列运动数据 - 在给定前一帧的情况下学习下一帧中的姿势。莱文等人 [2012] 在 GPLVM 减少的空间中应用强化学习来计算诸如运动、踢腿和拳击等任务的最佳运动。

> **[warning]** GPLVM 减少的空间？

---

基于内核的方法（如 RBF 和 GP）存在较大的内存成本。 因此，可以混合的运动数量是有限的。 我们的方法没有这样的限制，可以扩展到大量的训练数据集。

> **[warning]** 为什么RBF和GP需要较大的内存成本  

---

**交互式角色控制** 对于交互式角色控制，需要一种基于高级命令产生连续运动的机制。 运动图 [Arikan 和 Forsyth 2002； 李等人 2002; 科瓦尔等人 2002] 是用于此目的的有效数据结构。 运动图是从大量运动捕捉数据中自动计算出来的。  

> **[success]**  
运动图是一种数据结构。自动计算出来的应该不是结构，而是结构上的数据。  
运动图和文的RBF一样，从原始运动数据中提取某些特殊信息，特殊信息的混合就是运动的合成。只是提取特殊信息的方法不同，RBF方法使用预设的规则，这里使用自动学习，而本文使用AutoEncoder。  

由于运动图仅重放已捕获的运动数据，因此用于混合同一类运动以丰富数据集 [Min and Chai 2012; Heck 和 Gleicher 2007； Safonova 和 Hodgins 2007； Shin 和 Oh 2006； 莱文等人 2012]。  

> **[success]** 运动图不能产生新的运动，只能用于丰富已有运动的数据集。  

---

许多在交互式角色控制期间应用运动混合进行运动合成的方法都需要对运动进行分类、分割和对齐，以生成每个运动类的丰富模型。 不同时期、不同类别的姿势不能混用。   

> **[success]** 分类是因为不同类别的姿势不能混用。对齐是因为不同时期的姿势不能混用。分割是把序列分割成不同类别的动作。  

尽管 Kovar 和 Gleicher [2004] 尝试使此过程自动化，但运动之间的距离度量和运动序列的分割标准的选择会显著影响性能和准确性。 必须明确地执行这些步骤，这可能是其性能的瓶颈。 相反，我们的无监督框架会自动融合附近的运动以合成逼真的运动，而无需任何运动分割和分类。

---

这些论文应用了基于强化学习的技术，用于在遵循用户指令的每个时间步找到最佳动作 [Lee and Lee 2004; Safonova 和 Hodgins 2007；李等人 2010年；莱文等人 2012]。强化学习需要大量的预计算，这些预计算相对于角色可用的动作数量呈指数增长。出于这个原因，诸如运动场之类的方法 [Lee 等人。 2010] 随着数据量和控制参数数量的增长，很快变得难以处理，需要使用各种附加技术来减少状态数量。

> **[warning]** 运动场之类的方法?

例如，莱文等人 [2012] 预先将运动数据集分类为不同的类，并降低每个运动类中的维数。我们避免使用强化学习，而是将用户给出的高级命令直接回归到低级运动特征。这种映射是通过随机梯度下降计算的，并且不是像在强化学习中那样随着控制参数的数量而增长。

> **[success]** 强化学习不直接给Target，而是给predict的评价。机器要自己理解什么predict是好的。但回归方法直接告诉机会target，接近Target的predict就是好的predict。  

---

**运动数据的深度学习** 基于深度学习的技术目前是图像和语音识别领域的最新技术 [Krizhevsky et al. 2012年； 格雷夫斯等人 2013]。 最近，人们对应用深度学习技术从学习模型中合成新数据产生了巨大的兴趣 [Vincent et al. 2010年； 古德费洛等人 2014]。

> **[warning]** 从学习模型中合成新数据是什么意思？

基于深度学习的框架的一项重要优势是它们可以自动从数据集中学习特征。

> **[warning]** 所有的机器学习都是自己从数据集中学习特征，为什么说是深度学习的优势？

例如，当卷积神经网络 (CNN) 应用于图像识别时，类似于 Gabor 过滤器的过滤器出现在底层，而对应于不同对象的更复杂的过滤器出现在更高层 [Zeiler and Fergus 2014]。 我们的主要兴趣之一就是将这种力量用于角色动画。

---

深度学习和神经网络也吸引了控制社区的兴趣。控制社区以机器人和基于物理的动画为应用场景。 Allen 和 Faloutsos [2009] 使用 NEAT 算法，该算法改进了神经网络的拓扑结构以控制双足动物。 谭等人 [2014] 将此技术应用于自行车特技控制。 Levine 和 Vladlen [2014] 使用神经网络学习最佳控制策略并将其应用于双足步态控制。 莫达奇等人 [2015] 应用循环神经网络 (RNN) 来学习用于关节字符的近乎最优的反馈控制器。 虽然这些方法学习在物理环境中控制角色的动力学，但我们的重点是从捕获的人体运动数据中学习特征并将其应用于动画制作。

---

有几种方法可以将深度学习应用于人体动作捕捉数据。   

> **[warning]** 应用人体捕捉数据是什么Task？  

杜等人 [2015] 使用来自各种来源的大型运动数据集构建分层 RNN，并展示他们的方法达到了SOTA的识别率。 霍尔顿等人 [2015] 将卷积自动编码器应用于 CMU 运动捕捉数据库，并表明学习到的表示在运动检索等任务中取得了良好的性能。

---

在运动合成方面，Taylor 等人 [2009; 2011] 应用条件受限玻尔兹曼机 (cRBM) 来合成步态动画。  

> **[warning]** cRBM?  

米特尔曼等人 [2014] 使用循环时间 RBM 的尖峰和平板版本来改进重建。  

> **[warning]** 循环时间RBM  

Fragkiadaki 等 [2015] 介绍了编码器-循环-解码器 (ERD) 网络，这是一种将表征学习与学习时间动态相结合的 RNN，可在减少漂移的同时产生平滑的插值运动。这些是时间序列方法，计算整个运动需要从第一帧开始积分。我们发现这个框架不太适合动画制作的目的，因为动画师希望一次看到整个动作，然后在修改动作的同时依次应用小编辑。他们不希望看到在早期帧发生的编辑被传播到未来，采用时间序列方法时就会出现这种情况。

> **[warning]** 缺点没看懂

出于这个原因，在本文中，我们采用并改进了卷积自编码器表示 [Holden 等人 2015] 可以立即并行地产生运动，而无需执行任何集成过程。

# 系统总览

系统的轮廓如图 2 所示。使用来自大型人体运动数据库的数据（参见第 4 节），训练卷积自动编码器，从而找到通用运动流形（图 2 中的绿色框，参见第 5 节） ）。经过这种训练，运动可以由网络的隐藏单元来表示。给定这种表示，通过堆叠在卷积自动编码器顶部的前馈神经网络（图 2 中的橙色框，参见第 6 节）在高级控制参数和隐藏单元之间产生映射。本作品中显示的高级控制参数是角色在地形上的轨迹和末端执行器的运动。由于这些参数化可能包含歧义，因此使用另一个小型网络来计算消除输入歧义的参数（图 2 中的红色框，参见第 6.3 节）。仅使用与任务相关的运动捕捉数据的子集来训练这些前馈网络。使用这个框架，用户可以通过在地形上绘制曲线来制作角色行走和奔跑的动画，或者用户可以通过指定手和脚的轨迹让角色出拳和踢腿。一旦生成了运动，就可以在隐藏单元的空间中对其进行编辑，从而使产生的运动满足约束条件，例如足部滑板清理的位置约束（参见第 7.1 节）。使用这种技术，我们描述了一种使用短风格化剪辑作为参考来转换角色运动风格的方法（第 7.2 节）。

# 数据采集

在本节中，我们将描述我们构建适合深度学习的大型运动数据库。

## 深度学习的运动数据集

我们通过收集许多免费的大型在线运动捕捉数据库 [CMU ; 穆勒等人 2007; 奥弗里等人 2013年； 夏等人 2015]，以及添加来自我们内部捕获的数据，并将它们重新定位到具有单一比例和相同骨骼长度的统一骨架结构。 重定向是通过首先将源骨架结构中的任何相应关节角度复制到目标骨架结构，然后将源骨架缩放到与目标骨架相同的大小，最后执行全身逆运动学方案来完成的[Yamane and Nakamura 2003]移动目标骨骼的关节以匹配源骨骼中的任何相应关节位置。  

> **[warning]**  
既然已经将数据复制到目标骨架上，为什么要对源骨架做缩放？  
全身逆运动学方案？  
关节角度定了动作就定了，为什么还有匹配关节位置？  

构建完成后，最终数据集的大小约为 CMU 运动捕捉数据库的两倍，其中包含以每秒 120 帧采样的单个角色的约 600 万帧高质量运动捕捉数据。

## 训练数据格式

我们将数据集转换为适合训练的格式。我们将数据库中的所有运动子采样为每秒 60 帧，并将数据从原始数据集中的关节角度表示转换为 3D 关节位置格式。关节位置在身体的局部坐标系中定义，其原点位于根位置投影到的地面上。身体的向前方向（Z 轴）是使用跨越左右肩部和臀部的向量计算的，对它们求平均并计算与垂直轴（Y 轴）的叉积。这一步使用了高斯滤波器平滑以消除任何高频移动。 XZ 平面中的全局速度以及每一帧中身体绕垂直轴（Y 轴）的旋转速度都附加到输入表示中。  

> **[success]**  
原点：根位置投影到的地面上  
x轴：身体的左手方向  
y轴：身体向上的方向  
z轴：身体向前的方向  
xz平面的全局速度：身体向前后、左右移动的速度  

这些可以随着时间的推移进行整合以恢复运动的全局平移和旋转。脚接触标签是通过检测角色的脚趾或脚跟何时低于特定高度和速度来发现的 [Lee et al. 2002]，并且还附加到输入表示。从数据中减去平均姿态，然后将关节位置除以标准差以归一化角色的比例。速度和接触标签也除以它们自己的标准偏差。

> **[warning]** 什么是平均姿态？为什么要减掉？  

---

我们发现联合位置表示有效有几个原因：该表示中两个姿势之间的欧几里德距离与姿势的视觉差异非常匹配，可以使用简单的线性算子对多个姿势进行插值，并且在这种表示中自然地制定了许多约束。

---

一般情况下，我们的模型并不要求运动片段具有固定长度，但是在训练期间固定窗口大小可以提高速度，因此我们将运动数据库分离为 n 帧的重叠窗口（重叠 n/2 帧），我们在实验中使用 n = 240。 这样得到了最终输入向量X，一个向量代表来自数据库的单个样本，X ∈ Rn×d，其中 n 是窗口大小，d 是身体模型的自由度，在我们的实验中为 70。 训练后窗口大小 n 在我们的框架中不是固定的，因此它可以处理任意长度的运动。

# 构建运动流形

为了在人体运动空间上构建流形，我们构建了一个自动编码卷积神经网络，并在完整的运动数据库上对其进行训练。 我们遵循 Holden 等人的方法。 [2015]，但采用不同的设置来优化运动合成网络。 首先，我们只使用单层对运动进行编码，因为由于网络的池化层降低了数据的时间分辨率，多层池化/去池化会导致重建后运动模糊。 仅使用一层缺乏进一步抽象低级特征的能力，因此该任务由第 6 节中描述的深度前馈网络执行。我们还更改了几个组件以提高网络训练的性能和基础质量。 详情如下。

## 网络结构

在我们的框架中，卷积自动编码器对每个过滤器独立地在时域上执行一维卷积。 网络提供*前向操作* $\Phi$（编码）和*后向操作* $\Phi^\top$（解码）。 前向操作在可见单元空间接收输入向量X，并在隐藏单元空间输出编码值H。

---

前向操作：

由使用权重矩阵 W0 ∈ Rm×d×w0 的卷积（用 ∗ 表示）、偏置 b0 ∈ Rm、最大池化操作 Ψ 和非线性操作 ReLU(x) = max(x, 0) 组成，其中 w0 是时间滤波器宽度，m 是自动编码层中隐藏单元的数量，在这项工作中分别设置为 25 和 256； 25 的时间滤波器宽度确保每个滤波器大致对应于半秒的运动，而实验发现 256 个隐藏单元可以产生良好的重建。

---

最大池化操作 Ψ 返回时间轴上每对连续隐藏单元的最大值。 这降低了时间分辨率，确保学习到的基专注于代表性特征，并且还允许基表达一定程度的时间不变性。 我们使用整流线性运算 ReLU 而不是常见的 tanh 运算，因为 Nair 和 Hinton [2010] 证明了其作为激活函数的性能。

---

后向操作：

将隐藏单元 H ∈ R n2 ×m 作为输入，由逆池化操作、偏置 b0 的减法和使用权重矩阵 $\tilde {W0}$ 的卷积组成。 $\tilde {W0}$ ∈ Rd×m×w0 只是权重矩阵 W0 反映在时间轴上，并在前两个轴上转置，用于反转卷积运算。

---

在执行逆池化操作时，隐藏层中的每个单元必须在可见层中产生两个单元（在前向操作期间池化的那些）。 因此，该操作是不可逆的，必须使用近似值。 在训练期间 $\Psi^\top$ 在两个相应的可见单元之间随机选择并将完整值分配给其中一个单元，而将另一个单元设置为零。 这代表了最大值运算的倒数的良好近似，但会在结果中引入噪声。 因此，在执行综合时 $\Psi^\top$ 就像一个平均池化操作，并将隐藏单元值均匀地分布在两个可见单元上。

---

过滤器值 W0 被初始化为使用“扇入”和“扇出”标准找到的一些小的随机值 [Hinton 2012]，而偏差 b0 被初始化为零。

## 训练自动编码器

我们训练网络在前向和后向操作之后重现一些输入 X。**因此，训练作为一个优化问题给出。** 我们最小化以下关于网络参数的成本函数，θ = {W0, b0} ：

在这个等式中，第一项测量平方再现误差，第二项表示额外的稀疏项，确保使用最少数量的网络参数来再现输入。这是由一些小常数 α 调节的，在我们的例子中设置为 0.1。
