# 摘要

我们提出了一个基于高级参数的合成角色运动的框架，这样产生的运动尊重人体运动流形。

> **[warning]**
> 什么是高级参数？

这个框架在大型运动捕捉数据集上训练。学习到的运动流形由卷积自动编码器的隐藏单元表示。它代表了稀疏分量中的运动数据，这些分量可以组合以产生广泛的复杂运动。为了从高级参数映射到运动流形，我们在经过训练的自动编码器之上堆叠了一个深度前馈神经网络。该网络经过训练，可根据参数生成逼真的运动序列，例如角色应遵循的地形曲线，或拳打脚踢的目标位置。前馈控制网络和运动流形是独立训练的。这允许用户根据所需的接口在前馈网络之间轻松切换，而无需重新训练运动流形。一旦生成运动，就可以通过在运动流形空间中执行优化来对其进行编辑。这允许施加运动学约束，或改变运动的风格，同时确保编辑的运动保持自然。因此，该系统可以生成平滑、高质量的运动序列，而无需对训练数据进行任何手动预处理。

> **[success]**
> 用卷积自动编码器训练运行流形。
> 用深度前馈神经网络生成运动序列。

---

**关键词**：深度学习，卷积神经网络，自编码器，人体运动，角色动画，流形学习
**概念： •计算方法→运动捕捉**；

# 介绍

数据驱动的运动合成允许动画师根据高级参数生成令人信服的角色运动。 这种方法极大地帮助了动画制作，因为动画师只需要通过关键帧提供高级指令而不是低级细节。 计算机动画中已经提出了各种利用大型运动捕捉数据集和机器学习来参数化运动的技术。

---

目前可用的大多数数据驱动方法都需要大量的手动数据预处理，包括运动分割、对齐和标记。 任何阶段的错误都很容易导致最终动画的失败。 因此，这种预处理通常是通过大量人工干预小心执行的，以确保输出运动看起来平滑自然。 这使得完全自动化变得困难，因此这些系统通常需要专门的技术开发人员来维护。

---

在本文中，我们提出了一种基于深度学习框架的动画合成和编辑模型，该模型可以使用大量人体运动数据自动学习非线性流形中运动数据的嵌入，无需手动数据预处理或人为干涉。

> **[warning]** 运动数据的嵌入（embedding）是什么？

我们在大型运动数据库上训练卷积自动编码器，以便它可以再现给出的运动数据并作为后续的输入，还可以通过插值合成新的运动。

> **[warning]** Embedding为什么能再现运动数据？为什么能合成新的运行数据？

这种无监督的非线性流形学习过程不需要任何运动分割或对齐，这使得该过程比以前的方法容易得多。在这个自动编码器之上，我们堆叠了另一个前馈神经网络，它将高级参数映射到低级人体运动，由自动编码器的隐藏单元表示。

> **[warning]** 什么是高级参数？什么是低级人体运动？高级和低级从哪里来？为什么由隐藏单元表示，还不是输出层表示？

有了这个，用户可以从直观的输入中轻松生成逼真的人体运动序列，例如角色应该遵循的某些地形上的曲线，或者用于拳击和踢腿的末端执行器的轨迹。由于前馈控制网络和运动流形是独立训练的，用户可以根据所需的接口轻松交换和重新训练前馈网络。我们的方法本质上也是并行的，这使得计算速度非常快，并且非常适合主流动画包。

---

我们还提出了在运动流形空间中编辑运动数据的技术。 卷积自编码器的隐藏单元以稀疏和连续的方式表示运动，因此调整该空间中的数据可以保持运动的自然性和平滑性，同时仍然允许再现身体的复杂运动。 这种编辑的一个示范示例是通过最小化合成运动的隐藏单元与参考运动的隐藏单元的 Gram 矩阵之间的差异，将一种运动的风格与另一种运动的时间相结合 [Gatys et al. 2015]。

---

总之，我们的贡献如下：

- 一个快速、并行的深度学习框架，用于从高级参数合成角色动画。
- 一种在运动流形上进行运动编辑的方法，用于满足用户约束和变换运动风格。

# 相关工作

我们首先回顾基于内核的运动合成方法，这些方法一直是通过混合运动捕捉数据来合成运动的主要技术。

> **[warning]** 运动捕捉数据是指什么？

我们接下来回顾交互式角色控制的方法，其中用户指令用于使用运动数据库合成新运动。 最后，我们回顾了深度学习中的方法以及它们如何应用于角色动画。

---

**基于内核的运动混合方法** 径向基函数 (RBF) 可有效混合同一类的多个运动。罗斯等人 [1998] 将同一类的动作称为“动词”，并根据角色需要移动或伸出的方向使用 RBF 对它们进行插值。罗斯等人 [2001] 通过将关节位置映射到角色的姿势，展示了 RBF 的反向运动学用法。

> **[warning]** 反向运行学？

为了使混合运动看起来合理，需要沿着时间线对运动进行分类和对齐。 Kovar 和 Gleicher [2004] 通过计算运动的相似性并使用动态时间扭曲对齐它们来自动化这个过程。然而，由于缺乏处理噪声和方差的机制，RBF 方法很容易过拟合数据。 Mukai 和 Kuriyama [2005] 通过使用高斯过程 (GP) 克服了这个问题，其中优化了元参数以使模型适合数据。

> **[warning]** 元参数是超参数的意思吗？用GP克服过拟合是指人为加噪？

格罗乔等人 [2004] 应用高斯过程潜在变量模型 (GPLVM) 将运动数据映射到低维空间，以便动画师可以直观地控制角色。

> **[warning]** 高斯过程潜在变量模型 (GPLVM)？

王等人 [2005] 将 GPLVM 应用于时间序列运动数据 - 在给定前一帧的情况下学习下一帧中的姿势。莱文等人 [2012] 在 GPLVM 减少的空间中应用强化学习来计算诸如运动、踢腿和拳击等任务的最佳运动。

> **[warning]** GPLVM 减少的空间？

---

基于内核的方法（如 RBF 和 GP）存在较大的内存成本。 因此，可以混合的运动数量是有限的。 我们的方法没有这样的限制，可以扩展到大量的训练数据集。

---

**交互式角色控制** 对于交互式角色控制，需要一种基于高级命令产生连续运动的机制。 运动图 [Arikan 和 Forsyth 2002； 李等人 2002; 科瓦尔等人 2002] 是用于此目的的有效数据结构。 运动图是从大量运动捕捉数据中自动计算出来的。 由于运动图仅重放已捕获的运动数据，因此用于混合同一类运动以丰富数据集 [Min and Chai 2012; Heck 和 Gleicher 2007； Safonova 和 Hodgins 2007； Shin 和 Oh 2006； 莱文等人 2012]。

---

许多在交互式角色控制期间应用运动混合进行运动合成的方法都需要对运动进行分类、分割和对齐，以生成每个运动类的丰富模型。 不同时期、不同类别的姿势不能混用。 尽管 Kovar 和 Gleicher [2004] 尝试使此过程自动化，但运动之间的距离度量和运动序列的分割标准的选择会显著影响性能和准确性。 必须明确地执行这些步骤，这可能是其性能的瓶颈。 相反，我们的无监督框架会自动融合附近的运动以合成逼真的运动，而无需任何运动分割和分类。

---

这些论文应用了基于强化学习的技术，用于在遵循用户指令的每个时间步找到最佳动作 [Lee and Lee 2004; Safonova 和 Hodgins 2007；李等人 2010年；莱文等人 2012]。强化学习需要大量的预计算，这些预计算相对于角色可用的动作数量呈指数增长。出于这个原因，诸如运动场之类的方法 [Lee 等人。 2010] 随着数据量和控制参数数量的增长，很快变得难以处理，需要使用各种附加技术来减少状态数量。

> **[warning]** 运动场之类的方法?

例如，莱文等人 [2012] 预先将运动数据集分类为不同的类，并降低每个运动类中的维数。我们避免使用强化学习，而是将用户给出的高级命令直接回归到低级运动特征。这种映射是通过随机梯度下降计算的，并且不会随着控制参数的数量而增长，正如在强化学习中那样。

> **[warning]** 前面一半把强化学习作为反而教材，最后一句又以强化学习作为正面的例子，啥情况？

---

**运动数据的深度学习** 基于深度学习的技术目前是图像和语音识别领域的最新技术 [Krizhevsky et al. 2012年； 格雷夫斯等人 2013]。 最近，人们对应用深度学习技术从学习模型中合成新数据产生了巨大的兴趣 [Vincent et al. 2010年； 古德费洛等人 2014]。

> **[warning]** 从学习模型中合成新数据是什么意思？

基于深度学习的框架的一项重要优势是它们可以自动从数据集中学习特征。

> **[warning]** 所有的机器学习都是自己人数据集中学习特征，为什么说是深度学习的优势？

例如，当卷积神经网络 (CNN) 应用于图像识别时，类似于 Gabor 过滤器的过滤器出现在底层，而对应于不同对象的更复杂的过滤器出现在更高层 [Zeiler and Fergus 2014]。 我们的主要兴趣之一就是将这种力量用于角色动画。

---

深度学习和神经网络也吸引了控制社区的兴趣。控制社区以机器人和基于物理的动画为应用场景。 Allen 和 Faloutsos [2009] 使用 NEAT 算法，该算法改进了神经网络的拓扑结构以控制双足动物。 谭等人 [2014] 将此技术应用于自行车特技控制。 Levine 和 Vladlen [2014] 使用神经网络学习最佳控制策略并将其应用于双足步态控制。 莫达奇等人 [2015] 应用循环神经网络 (RNN) 来学习用于关节字符的近乎最优的反馈控制器。 虽然这些方法学习在物理环境中控制角色的动力学，但我们的重点是从捕获的人体运动数据中学习特征并将其应用于动画制作。

---

有几种方法可以将深度学习应用于人体动作捕捉数据。 杜等人 [2015] 使用来自各种来源的大型运动数据集构建分层 RNN，并展示他们的方法达到了SOTA的识别率。 霍尔顿等人 [2015] 将卷积自动编码器应用于 CMU 运动捕捉数据库，并表明学习到的表示在运动检索等任务中取得了良好的性能。

---

在运动合成方面，Taylor 等人 [2009; 2011] 应用条件受限玻尔兹曼机 (cRBM) 来合成步态动画。米特尔曼等人 [2014] 使用循环时间 RBM 的尖峰和平板版本来改进重建。 Fragkiadaki 等 [2015] 介绍了编码器-循环-解码器 (ERD) 网络，这是一种将表征学习与学习时间动态相结合的 RNN，可在减少漂移的同时产生平滑的插值运动。这些是时间序列方法，计算整个运动需要从第一帧开始积分。我们发现这个框架不太适合动画制作的目的，因为动画师希望一次看到整个动作，然后在修改动作的同时依次应用小编辑。他们不希望看到在早期帧发生的编辑被传播到未来，采用时间序列方法时就会出现这种情况。

> **[warning]** 缺点没看懂

出于这个原因，在本文中，我们采用并改进了卷积自编码器表示 [Holden 等人 2015] 可以立即并行地产生运动，而无需执行任何集成过程。

# 系统总览

系统的轮廓如图 2 所示。使用来自大型人体运动数据库的数据（参见第 4 节），训练卷积自动编码器，从而找到通用运动流形（图 2 中的绿色框，参见第 5 节） ）。经过这种训练，运动可以由网络的隐藏单元来表示。给定这种表示，通过堆叠在卷积自动编码器顶部的前馈神经网络（图 2 中的橙色框，参见第 6 节）在高级控制参数和隐藏单元之间产生映射。本作品中显示的高级控制参数是角色在地形上的轨迹和末端执行器的运动。由于这些参数化可能包含歧义，因此使用另一个小型网络来计算消除输入歧义的参数（图 2 中的红色框，参见第 6.3 节）。仅使用与任务相关的运动捕捉数据的子集来训练这些前馈网络。使用这个框架，用户可以通过在地形上绘制曲线来制作角色行走和奔跑的动画，或者用户可以通过指定手和脚的轨迹让角色出拳和踢腿。一旦生成了运动，就可以在隐藏单元的空间中对其进行编辑，从而使产生的运动满足约束条件，例如足部滑板清理的位置约束（参见第 7.1 节）。使用这种技术，我们描述了一种使用短风格化剪辑作为参考来转换角色运动风格的方法（第 7.2 节）。

# 数据采集

在本节中，我们将描述我们构建适合深度学习的大型运动数据库。

## 深度学习的运动数据集

我们通过收集许多免费的大型在线运动捕捉数据库 [CMU ; 穆勒等人 2007; 奥弗里等人 2013年； 夏等人 2015]，以及添加来自我们内部捕获的数据，并将它们重新定位到具有单一比例和相同骨骼长度的统一骨架结构。 重定向是通过首先将源骨架结构中的任何相应关节角度复制到目标骨架结构，然后将源骨架缩放到与目标骨架相同的大小，最后执行全身逆运动学方案来完成的[Yamane and Nakamura 2003]移动目标骨骼的关节以匹配源骨骼中的任何相应关节位置。 构建完成后，最终数据集的大小约为 CMU 运动捕捉数据库的两倍，其中包含以每秒 120 帧采样的单个角色的约 600 万帧高质量运动捕捉数据。

## 训练数据格式

我们将数据集转换为适合训练的格式。我们将数据库中的所有运动子采样为每秒 60 帧，并将数据从原始数据集中的关节角度表示转换为 3D 关节位置格式。关节位置在身体的局部坐标系中定义，其原点位于根位置投影到的地面上。身体的向前方向（Z 轴）是使用跨越左右肩部和臀部的向量计算的，对它们求平均并计算与垂直轴（Y 轴）的叉积。这是使用高斯滤波器平滑以消除任何高频移动。 XZ 平面中的全局速度以及每一帧中身体绕垂直轴（Y 轴）的旋转速度都附加到输入表示中。这些可以随着时间的推移进行整合以恢复运动的全局平移和旋转。脚接触标签是通过检测角色的脚趾或脚跟何时低于特定高度和速度来发现的 [Lee et al. 2002]，并且还附加到输入表示。从数据中减去平均姿态，然后将关节位置除以标准差以归一化角色的比例。速度和接触标签也除以它们自己的标准偏差。

---

我们发现联合位置表示有效有几个原因：该表示中两个姿势之间的欧几里德距离与姿势的视觉差异非常匹配，可以使用简单的线性算子对多个姿势进行插值，并且在这种表示中自然地制定了许多约束。

---

一般情况下，我们的模型并不要求运动片段具有固定长度，但是在训练期间固定窗口大小可以提高速度，因此我们将运动数据库分离为 n 帧的重叠窗口（重叠 n/2 帧），我们在实验中使用 n = 240。 这样得到了最终输入向量X，一个向量代表来自数据库的单个样本，X ∈ Rn×d，其中 n 是窗口大小，d 是身体模型的自由度，在我们的实验中为 70。 训练后窗口大小 n 在我们的框架中不是固定的，因此它可以处理任意长度的运动。

# 构建运动流形

为了在人体运动空间上构建流形，我们构建了一个自动编码卷积神经网络，并在完整的运动数据库上对其进行训练。 我们遵循 Holden 等人的方法。 [2015]，但采用不同的设置来优化运动合成网络。 首先，我们只使用单层对运动进行编码，因为由于网络的池化层降低了数据的时间分辨率，多层池化/去池化会导致重建后运动模糊。 仅使用一层缺乏进一步抽象低级特征的能力，因此该任务由第 6 节中描述的深度前馈网络执行。我们还更改了几个组件以提高网络训练的性能和基础质量。 详情如下。

## 网络结构

在我们的框架中，卷积自动编码器对每个过滤器独立地在时域上执行一维卷积。 网络提供*前向操作* $\Phi$（编码）和*后向操作* $\Phi^\top$（解码）。 前向操作在可见单元空间接收输入向量X，并在隐藏单元空间输出编码值H。

---

前向操作：

由使用权重矩阵 W0 ∈ Rm×d×w0 的卷积（用 ∗ 表示）、偏置 b0 ∈ Rm、最大池化操作 Ψ 和非线性操作 ReLU(x) = max(x, 0) 组成，其中 w0 是时间滤波器宽度，m 是自动编码层中隐藏单元的数量，在这项工作中分别设置为 25 和 256； 25 的时间滤波器宽度确保每个滤波器大致对应于半秒的运动，而实验发现 256 个隐藏单元可以产生良好的重建。

---

最大池化操作 Ψ 返回时间轴上每对连续隐藏单元的最大值。 这降低了时间分辨率，确保学习到的基专注于代表性特征，并且还允许基表达一定程度的时间不变性。 我们使用整流线性运算 ReLU 而不是常见的 tanh 运算，因为 Nair 和 Hinton [2010] 证明了其作为激活函数的性能。

---

后向操作：

将隐藏单元 H ∈ R n2 ×m 作为输入，由逆池化操作、偏置 b0 的减法和使用权重矩阵 $\tilde {W0}$ 的卷积组成。 $\tilde {W0}$ ∈ Rd×m×w0 只是权重矩阵 W0 反映在时间轴上，并在前两个轴上转置，用于反转卷积运算。

---

在执行逆池化操作时，隐藏层中的每个单元必须在可见层中产生两个单元（在前向操作期间池化的那些）。 因此，该操作是不可逆的，必须使用近似值。 在训练期间 $\Psi^\top$ 在两个相应的可见单元之间随机选择并将完整值分配给其中一个单元，而将另一个单元设置为零。 这代表了最大值运算的倒数的良好近似，但会在结果中引入噪声。 因此，在执行综合时 $\Psi^\top$ 就像一个平均池化操作，并将隐藏单元值均匀地分布在两个可见单元上。

---

过滤器值 W0 被初始化为使用“扇入”和“扇出”标准找到的一些小的随机值 [Hinton 2012]，而偏差 b0 被初始化为零。

## 训练自动编码器

我们训练网络在前向和后向操作之后重现一些输入 X。**因此，训练作为一个优化问题给出。** 我们最小化以下关于网络参数的成本函数，θ = {W0, b0} ：

在这个等式中，第一项测量平方再现误差，第二项表示额外的稀疏项，确保使用最少数量的网络参数来再现输入。这是由一些小常数 α 调节的，在我们的例子中设置为 0.1。

---

为了最小化这个函数，我们执行随机梯度下降。 我们从数据库中输入随机元素 X，并使用通过 Theano 计算的自动导数 [Bergstra 等人 2010] 更新网络参数θ。 我们利用自适应梯度下降算法 Adam [Kingma and Ba 2014] 来提高最终基础的训练速度和质量。 为了避免过度拟合，我们使用 Dropout [Srivastava 等人 2014] 为 0.2。 训练在 NVIDIA GeForce GTX 660 GPU 上执行 15 个时期，大约需要 6 个小时。 

---

一旦训练完成，过滤器就会表达强烈的时间和关节间的对应关系。 结果权重的可视化可以在图 3 中看到。这里显示了每个过滤器表达了一段时间内几个关节的运动。 

---

# 将高级参数映射到人体运动 

我们使用前馈卷积神经网络学习高级参数和角色运动之间的回归。高级参数是描述运动的抽​​象参数，例如投影到地形上的根轨迹或手脚等末端执行器的轨迹。这是一个通用框架，可以应用于各种类型的高级参数和动画输出。由于输出中存在大量的模糊性和多模态，因此在低维、高级参数与全身运动之间生成映射是一项艰巨的任务。可以执行许多不同的有效运动以遵循高级参数。例如，当角色被指示沿着一条线行走时，动作的时间是完全不变的：一个角色可能以不同的步长行走，或者与在同一轨迹上执行的另一个动作不同步。天真地混合这些不同步的运动会导致输出的平均，使角色看起来沿着路径漂浮。不幸的是，没有解决这种模糊问题的通用解决方案，每个问题都必须根据高级参数的性质和输出运动的类别单独解决。在这里，我们为运动任务提供了一个解决方案，这是一个需求量很大的普遍问题。 

---

在本节的其余部分，我们首先描述前馈网络的结构以及如何训练它，然后描述运动任务的高级参数的细节。 

## 前馈网络的结构 

我们现在描述前馈卷积网络，它将高级参数 T 映射到上一节中构建的自动编码网络的隐藏层，从而最终系统输出字符 X ∈ Rn×d 的运动。 

---

前馈卷积网络使用了一个类似的前向操作，如公式 1 中定义的那样。 （1）但包含三层，以及一个额外的操作Υ，它是解决歧义问题的特定于任务的操作。 我们将在第 6.3 节中详细讨论它。 前馈操作由以下给出： 

其中 W1 ∈ Rh1×l×w1 , b1 ∈ Rh1 , W2 ∈ Rh2×h1×w2 , b2 ∈ Rh2 , W3 ∈ Rm×h2×w3 , b3 ∈ Rm, h1, h2 是两个隐藏单元中的隐藏单元数 前馈网络的层数，w1、w2、w3是三个卷积算子的滤波器宽度，l是高层参数的自由度，分别设置为64、128、45、25、15和7。 这些滤波器宽度确保使用大约一秒的轨迹信息生成每一帧运动。 因此，用于回归的该前馈网络的参数由 φ = {W1,W2,W3, b1, b2, b3} 给出。 

## 训练前馈网络 

为了训练高级参数和输出运动之间的回归，我们以与第 5.2 节中解释的相同的方式使用随机梯度下降来最小化成本函数，但这次是关于前馈网络的参数，保持参数 自动编码网络已修复。 成本函数定义如下，由两项组成： 

第一项计算回归的均方误差，第二项是稀疏项，以确保使用最少数量的隐藏单元来执行回归。 和以前一样，α 设置为 0.1。 

---

在训练这个网络时，我们只使用与任务相关的数据。 例如，在运动任务期间，我们只使用运动特定的数据。 因此，训练比自动编码器花费的时间要少得多。 对于运动任务，训练进行了 200 个 epoch，大约需要 1 小时。 

## 运动消歧 

在本节中，我们描述了在给定地形上绘制的曲线的情况下消除运动歧义的解决方案。 仅地形上的曲线并不能提供足够的信息来完全描述由于上述歧义问题而应产生的运动。 我们检查了各种类型的输入，发现提供脚与地面接触的时间可以极大地消除运动的歧义。 事实上，接触时间甚至可以区分步行和跑步，因为步行总是有双支撑阶段，而跑步总是有飞行阶段。 因此，我们训练了一个模型，该模型可用于从给定轨迹自动计算足部接触。 我们将其包含在前馈网络的输入中以解决歧义。 

---

该网络的输入是 XZ 平面上的平移速度和绕 Y 轴的旋转速度形式的轨迹，为每个时间步长且相对于路径 T ∈ Rn×k 的前向方向给出，其中 n 是 轨迹中的帧数，k 是轨迹输入的维数，即 3。字符高度被认为是常数。 这个输入被传递给方程 Υ 中的函数 Υ。 (4)，它在轨迹输入中添加了脚接触信息： 

其中 F∈{−1, 1}n×4 是表示每帧左脚跟、左脚尖、右脚跟和右脚尖接触状态的矩阵，其与地面接触时的值为 1，并且 -1 否则。 

---

**通过方波建模接触状态**：我们使用四个方波对四个接触的状态进行建模，并以允许我们从轨迹 T 计算它们的方式从数据中学习这些波的参数。四个方波模拟了 四个触点，并产生 F，定义如下： 

其中 ω 和 τ 控制每一帧运动的频率和步长持续时间（见图 5），并且是我们有兴趣从轨迹计算的参数。 

仅这些参数就足以产生联系信息，但为了进行更多艺术控制，还提供了一些用户参数。 ah , at 是调整脚后跟和脚趾相位的常量， bh , bt 是可以用来调整脚后跟和脚趾接触持续时间的常量（因此迫使角色走路或跑步），而 c 是一个常数 可以缩放步进的频率。 在我们的实验中，我们将 ah、at 设置为 -0.1，将 0、bh、bt 设置为 0，将 c 设置为 1。 下面，我们将描述如何从运动数据中提取 ω 和 τ。 

---

**从数据中提取波浪参数**：为了在输入曲线 T 和参数 ω, τ 之间产生回归，我们需要首先从数据集中的脚接触信息中计算这些参数值。对于每一帧 i，角度 ωi 可以通过对微分 ωi = ∆ωi + ∆ωi−1 + ... + ∆ω0 求和来计算。因此，我们为数据中的每个帧 i 计算 ∆ωi。从数据集中，Δωi 可以通过 Δωi = Lπi 计算，其中 Li 是步长的波长，通过减去相邻的关闭到开启帧的时间，并对四个接触点（左/对，脚跟/脚趾）。从数据中学习 ∆ω 而不是 ω 还允许脚步频率在运动过程中发生变化，例如允许角色在转弯时走更多步。我们通过查看包括帧 i 的步态周期中的足部接触信息并取足部向上 ui 帧数与足部向下 di 帧数之比来提取 τi。可以使用以下公式将该比率转换为方波阈值 τi： 

---

对于每个脚跟和脚趾，我们学习单独的 τ 变量，而所有接触之间的 ∆ω 是相同的。 这避免了脚不同步。 这些参数被打包成一个矩阵Γ = {τ lh, τ lt, τ rh, τ rt , ∆ω}。 

---

**回归运动路径和接触信息**：现在我们描述我们如何在输入曲线 T 和接触方波参数 Γ 之间产生回归。 使用来自运动捕捉数据集的运动数据，我们通过将根关节的运动投影到地面上来计算运动路径 T。 我们还通过上述方法提取方波的相应Γ和足部接触参数。 然后我们使用一个小的两层卷积神经网络将 T 回归到 Γ。 

---

这里W4∈Rh4×k×w4，b4∈Rh4，W5∈Rl×h4×w5，b5∈Rl是这个网络的参数，其中w4，w5是滤波器宽度，h4是隐藏单元的数量，k , l 分别是每帧 T 和 Γ 的自由度，分别为 3 和 5。该网络使用随机梯度下降进行训练，如第 5.2 节所述。 

---

一旦这个网络被训练，给定一些轨迹 T，它计算 τ, Δω 的值，它可以用于使用公式计算 F。 (7)，因此产生轨迹的脚接触信息。 

# 隐藏单元空间中的运动编辑 

在本节中，我们将描述如何编辑或转换隐藏单元空间中的运动风格，这是自动编码器学习的运动数据的抽象表示。 因为运动是在隐藏单元的空间中编辑的，从而参数化了有效运动的流形，它确保即使在编辑之后，运动仍然保持平滑和自然。 我们将约束表示为相对于隐藏单元值的成本。 这种将运动编辑表述为最小化问题的公式通常既方便又强大，因为它指定了所需的编辑结果，而无需推断任何实现它的技术。 我们首先描述了一种应用运动学约束的方法（见第 7.1 节），然后是关于调整隐藏单元空间中运动的风格（见第 7.2 节）。 

---

## 在隐藏单元空间中应用约束 

由于运动编辑的范围非常大，我们首先使用角色动画中常见的三种常见约束来描述如何在隐藏空间中应用约束：位置约束、骨骼长度约束和轨迹约束，但我们的方法适用于 可以使用成本函数来描述提供约束的其他类型的约束。 请注意，所有这些成本同时计算所有帧的误差，并在时域上求和。 

---

**位置约束**：约束关节位置对于修复足部滑动伪影或引导角色的手抓住物体至关重要。 给定隐藏单元空间 H 中的初始输入运动，其违反位置约束的代价计算如下： 

其中 v0j ∈ Rn×3 是身体坐标系中关节 j 的目标速度， vrH, pHj , vjH ∈ Rn×3, ωH ∈ Rn 是根速度，关节 j 的局部位置和速度，以及身体的角速度 分别围绕 Y 轴，通过等式中的解码操作 Φ†(H) 从隐藏单元值 H 计算。 (2)，对于所有帧。 例如，为了避免足部滑动，脚跟和脚趾接触地面时的速度必须为零。 

---

**骨骼长度约束**：当我们在我们的框架中使用关节位置作为表示时，我们需要在相邻关节之间施加骨骼长度约束以保持身体的刚性。 这种约束的成本可以写成如下： 

其中 b 是身体中骨骼集的索引，pHi bj1 ，pHi bj2 是第 i 帧 b 的两个末端关节的重建 3D 位置，由等式中的解码操作 Φ†(H) 计算。 (2) lb 是
骨骼长度 B. 

---

**轨迹约束**：由于运动编辑或合成运动中的错误，可能无法完全遵循所需的轨迹。 因此，我们可能需要另外将运动精确地限制在某个轨迹上。 这种约束的成本可以写成如下： 

---

**投影到约束的空空间**：自动编码器生成的运动通过梯度下降在隐藏单元的空间中进行调整，直到总成本收敛在阈值内： 

---

通过最小化方程。 (13) 并使用等式将找到的 H0 投影回可见单位空间。 (2)，我们可以将关节约束到所需的位置，同时保持每个骨骼的刚度。 

## 隐藏单元空间中的运动风格化 

我们在隐藏空间中编辑运动的框架也可以用于使用示例运动剪辑作为参考来转换运动的风格。 盖蒂斯等人。 [2015] 描述了图像的艺术风格被编码在神经网络隐藏层的 Gram 矩阵中，并提供了将照片内容和绘画风格相结合的例子。 通过找到产生类似于参考数据的 Gram 矩阵的隐藏单元值，可以将输入图像调整为某种不同的样式，同时保留原始内容。 我们可以使用我们的框架将此技术应用于运动数据，并生成具有一个输入的时间和内容以及另一个输入样式的运动。 

---

在这种情况下，成本函数由与输出的内容和风格相关的两个术语定义。 给定一些定义生成输出内容的运动数据 C 和另一个定义生成输出样式的 S，隐藏单元 H 上的成本函数如下： 

其中 c 和 s 表示内容和风格的相对重要性，在我们的实验中分别设置为 1.0 和 0.01，函数 G 计算 Gram 矩阵，这是隐藏单元值的内积的平均值 时间域 i 可以被认为是隐藏单元的平均相似度或共激活： 

---

与在第 7.1 节中通过运动合成或自编码器的前向操作找到 H 不同，为避免偏向内容或风格，H 是从白噪声初始化的，并通过优化等式 3 来找到风格化的运动。 (14) 直到使用自适应梯度下降和通过 Theano 计算的自动导数收敛。 然后使用方程编辑计算出的运动。 (13) 满足运动学约束。 

# 实验结果

我们现在展示一些训练和合成角色动作的实验结果。 我们首先展示了使用高级参数和第 6 节中描述的框架对角色运动进行动画处理的示例，并投影到第 7.1 节中描述的约束的零空间。 我们接下来展示使用第 7.2 节中描述的框架应用程式化的示例。 由于我们的系统在运行时执行速度很快，因此适用于创建大量人群的动画。 因此，我们展示了这样一个例子。 然后，我们通过将其性能与可比较的网络结构进行比较来评估自编码器表示。 最后，我们将在本节末尾介绍计算的细分。 有关制作动画的详细信息，请参阅补充视频。 

---

**地形上的运动** 训练前馈网络，以便使用在地形上绘制的曲线来生成角色的实际运动。 在数据库中的数据中，使用不同速度和步进模式的各种类型的运动数据来训练系统。 使用训练数据，将根部的轨迹投影到地面上以生成地形曲线以用作输入。 

---

在运行时，Maya 绘制的曲线首先用于生成步行和跑步动画。 在前两个示例中，角色的速度是恒定的。 脚后跟和脚趾接触地面的时间由曲线自动生成，并用作前馈网络的输入。 角色在速度低时行走，在速度高时奔跑（见图 1）。 在下一个示例中，我们从一些未在训练中使用的测试集中获取身体速度曲线。 我们还通过 Maya 绘制角速度剖面来添加一些转动运动（见图 6）。 在最后一个示例中，我们使用来自测试数据项的速度曲线，其中角色加速和减速。 这适用于 Maya 绘制的地形曲线。 结果出现了从步行到停止和跑步的转变（见图 7）。 

---

**冲球和踢球控制** 我们展示了另一个示例，其中设置了前馈网络，以便角色出拳和踢腿以跟随用户提供的末端执行器轨迹。 我们使用未包含在训练集中的测试数据测试了系统。 角色生成遵循末端执行器轨迹的全身运动。 动画的一些快照如图 8 所示。 

---

**隐藏单元空间中的运动编辑** 在这里，我们展示了将约束应用于前馈网络生成的约束之前和之后的运动。 我们还通过逆运动学比较了在隐藏单元空间中编辑的运动与在笛卡尔空间中编辑的运动。 当在倾斜流形上编辑运动时，前者会产生更平滑的结果。 结果显示在视频中。 

---

**改变动作的风格** 我们接下来展示一个使用单独的运动剪辑转换角色运动风格的示例。 给出了角色以 (1) 僵尸风格 (2) 抑郁风格 (3) 老人风格和 (4) 受伤风格行走的风格数据，并通过自动编码器计算 Gram 矩阵。 这些 Gram 矩阵用于使用第 7.2 节中描述的优化方法转换给定运动数据的样式。 运动数据取自数据集，而样式数据是内部捕获和来自 [Xia et al. 2015]。 动画的快照如图 9 所示。 

---

**人群动画** 我们的方法允许使用 GPU 跨时间线进行并行计算。 这使我们可以同时为多个角色创建动作。 我们利用这个特性来应用我们的系统，使用第 6 节中描述的地形曲线框架来合成大量角色的动画。结果如图 10 所示。 

---

**自动编码器与其他网络结构的比较** 在这里，我们评估自动编码器找到的表示。 我们将其性能与没有最大池化或 dropout 的神经网络的幼稚构造进行比较。 如果在没有 dropout 或 max pooling 的情况下进行训练，则网络不会学习强大的时间连贯性，如图 4 所示。这种没有时间连贯性的运动流形与 per-pose PCA 非常相似——当应用于风格转移任务时， 在这个模型中没有编码时间平滑，输出非常嘈杂，如图 11 所示。 在运动合成任务中，没有最大池化或 dropout 的神经网络实际上具有略低的平均误差，但结果中存在类似的噪声 . 这可以在图 12 中看到。 

---

**计算分解** 在本节中，我们对呈现的每个结果的各种计算时间进行细分。 如表 1 所示。所有动画示例均以 60fps 的采样率生成。 对于人群场景，帧速率是通过找到所有 200 个角色生成的帧总数来给出的。 所有结果均使用 NVIDIA GeForce GTX 660 和 Theano 生成。 我们的技术显然可以很好地扩展，因为生成结果所需的总时间保持相似，即使是长序列的动画或许多角色。 所有时间都以秒为单位。 特别是我们的技术在人群场景中效果很好，因为它可以跨角色和跨时间线并行运行。 

# 讨论 

许多其他运动合成方法是时间序列方法 [Taylor and Hinton 2009;泰勒等人。 2011年；米特尔曼等人。 2014;夏等人。 2015]，但我们的运动合成方法是一种程序方法，因为它不需要逐步计算，并且可以按需生成任意时间的单个帧。这使得它非常适合动画制作软件，例如 Maya，它允许动画师跳转到时间轴中的任意点。动画师也不需要担心影响本地卷积窗口之外生成的动画的变化。这也使得系统高度可并行化，因为所有帧的运动都可以独立计算。因此，许多角色的轨迹可以在运行时在 GPU 上快速生成。跨时间线并行生成运动需要帧之间的连续性。这是由我们的框架以两种方式处理的。高层次的连续性（如计时）由足部接触信息的生成提供，而低层次的连续性（平滑度等）由歧管保证。 

---

尽管程序方法在角色动画中并不新鲜 [Lee and Shin 1999; 金等人。 2009; 敏等人。 2009]，以前的方法需要在将数据包含到模型中之前对运动进行分割、对齐和标记。 相反，我们的模型从大量运动数据中自动学习模型，无需手动标记或分割。 这使得系统非常实用，因为用户可以轻松地将新的运动数据添加到训练集中以丰富模型。 

---

我们的卷积滤波器仅沿时间轴移动；一个自然要问的问题是这种卷积是否也可以在空间上使用，例如，在字符的图形结构上。使用时间卷积模型的想法是确保自编码器的学习基础是局部的和不变的——它们的影响仅限于几帧，并且它们可以出现在时间轴的任何地方。这些局部性和不变性的假设在空间域中不能很好地概括。根据运动（例如，行走时手臂和腿同步），身体的各个不同部分之间存在很强的相关性，并且很难沿着图结构限制影响。另外，像手臂这样的底座一般不适用于身体的其他部位，这表明结构不是一成不变的。需要注意的是，我们的过滤器确实捕获了不同关节的相关性；不同自由度的信号在等式中的卷积运算中求和。 (1)，因此过滤器被优化以发现相关的运动。 

---

该系统有一些重要参数，这些参数是根据人体运动的性质并通过实验结果仔细确定的。这些包括人体运动的滤波器宽度（等式（1）中的 w0）和前馈网络的轨迹（等式（4）中的 w1、w2、w3）的滤波器宽度。对于人体运动的滤波器宽度 (w0 = 25)，这大约需要半秒。将此值设置得太长会导致运动过度平滑甚至无法训练。将其设置得太短会使系统像 per-pose 训练一样工作，无法从数据中学习运动的平滑度。对于前馈网络，过滤器宽度设置得稍长（w1 = 45，w2 = 25，w3 = 15），以便角色为未来事件做好足够早的准备。设置太短会导致缺乏变化，太长会导致过度拟合，在这种情况下会为新的轨迹产生奇怪的运动。这些值最初是通过直觉设置的，然后通过视觉分析进行微调。 

---

**限制** 在我们的框架中，前馈网络的输入参数需要仔细选择，以便高级参数和输出运动之间几乎没有歧义。 歧义是机器学习中的一个常见问题，当多个输出对应于训练数据中的相同输入时，回归器的输出会被平均。 在某些情况下，可能需要解决歧义的额外数据。 这可以由用户直接提供，或者必须使用其他模型找到，例如我们的脚接触模型。

# 结论 

我们提出了一种深度学习框架，通过首先使用大型运动数据库学习运动流形，然后在用户输入到输出运动之间生成映射，将高级参数映射到输出运动。 我们还提出了在同一框架下编辑和转换动作样式的方法。 

---

目前，我们的自动编码器只有一层，因为深度堆叠的自动编码器在去池过程中会出现模糊。 在我们的系统中，组合和抽象低级特征的作用由堆叠在其上的前馈网络覆盖。 然而，如果使用堆叠深度自动编码器来学习运动流形，则可以使用更简单的前馈网络，更容易训练。 研究诸如超列之类的新兴去池技术会很有趣 [Hariharan 等人。 2014] 处理模糊效应，为运动流形产生深度网络。 

# 致谢 

我们感谢审稿人提出的富有成效的建议。 这项研究得到了 Marza Animation Planet 的支持。 